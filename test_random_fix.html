<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>測試隨機選牌修復</title>
</head>
<body>
    <h1>測試隨機選牌重複問題修復</h1>
    <button onclick="testRandomKnownCards()">測試隨機已知牌</button>
    <button onclick="testRandomHandCards()">測試隨機手牌</button>
    <div id="result"></div>

    <script>
        // 模擬牌型資料
        const allCardTypes = ['天', '地', '人', '和', '梅', '長', '板', '斧', 
                              '紅頭', '高腳', '銅錘', '雜6', '雜7', '雜8', '雜9', '雜5'];

        // 舊版本的隨機選牌函數（有bug）
        function oldRandomKnownCards() {
            const knownCards = [];
            const selectedIndices = new Set();
            
            // 創建所有可用索引的數組 (0-31)
            const availableIndices = Array.from({length: 32}, (_, i) => i);
            
            // 隨機選16個索引
            const shuffled = availableIndices.sort(() => Math.random() - 0.5);
            const selectedIndicesToAdd = shuffled.slice(0, 16);
            
            // 根據索引設置選中狀態（舊邏輯）
            selectedIndicesToAdd.forEach(index => {
                selectedIndices.add(index);
                const cardType = allCardTypes[Math.floor(index / 2)];
                knownCards.push(cardType);
            });
            
            return knownCards;
        }

        // 新版本的隨機選牌函數（已修復）
        function newRandomKnownCards() {
            const knownCards = [];
            const selectedIndices = new Set();
            
            // 創建所有可用索引的數組 (0-31)
            const availableIndices = Array.from({length: 32}, (_, i) => i);
            
            // 隨機選16個索引
            const shuffled = availableIndices.sort(() => Math.random() - 0.5);
            const selectedIndicesToAdd = shuffled.slice(0, 16);
            
            // 使用 Map 來計算每種牌型的數量
            const cardTypeCount = new Map();
            
            // 根據索引設置選中狀態
            selectedIndicesToAdd.forEach(index => {
                selectedIndices.add(index);
                const cardType = allCardTypes[Math.floor(index / 2)];
                
                // 計算每種牌型出現的次數
                const count = cardTypeCount.get(cardType) || 0;
                cardTypeCount.set(cardType, count + 1);
            });
            
            // 根據計數添加牌到 knownCards
            cardTypeCount.forEach((count, cardType) => {
                for (let i = 0; i < count; i++) {
                    knownCards.push(cardType);
                }
            });
            
            return knownCards;
        }

        function checkDuplicates(cards) {
            const cardCount = {};
            let hasDuplicateError = false;
            
            cards.forEach(card => {
                cardCount[card] = (cardCount[card] || 0) + 1;
                if (cardCount[card] > 2) {
                    hasDuplicateError = true;
                }
            });
            
            return { cardCount, hasDuplicateError };
        }

        function testRandomKnownCards() {
            const resultDiv = document.getElementById('result');
            let html = '<h2>測試隨機已知牌（16張）</h2>';
            
            // 測試舊版本
            html += '<h3>舊版本（有bug）：</h3>';
            for (let i = 0; i < 5; i++) {
                const cards = oldRandomKnownCards();
                const { cardCount, hasDuplicateError } = checkDuplicates(cards);
                html += `<p>測試 ${i+1}: ${hasDuplicateError ? '❌ 有重複錯誤' : '✅ 正常'}</p>`;
                if (hasDuplicateError) {
                    html += '<ul>';
                    for (let card in cardCount) {
                        if (cardCount[card] > 2) {
                            html += `<li>${card}: ${cardCount[card]}張（應該最多2張）</li>`;
                        }
                    }
                    html += '</ul>';
                }
            }
            
            // 測試新版本
            html += '<h3>新版本（已修復）：</h3>';
            for (let i = 0; i < 5; i++) {
                const cards = newRandomKnownCards();
                const { cardCount, hasDuplicateError } = checkDuplicates(cards);
                html += `<p>測試 ${i+1}: ${hasDuplicateError ? '❌ 有重複錯誤' : '✅ 正常'}</p>`;
                if (hasDuplicateError) {
                    html += '<ul>';
                    for (let card in cardCount) {
                        if (cardCount[card] > 2) {
                            html += `<li>${card}: ${cardCount[card]}張（應該最多2張）</li>`;
                        }
                    }
                    html += '</ul>';
                }
            }
            
            resultDiv.innerHTML = html;
        }

        function testRandomHandCards() {
            const resultDiv = document.getElementById('result');
            let html = '<h2>測試隨機手牌（4張）</h2>';
            
            // 創建已知牌索引集合（模擬已選16張）
            const knownIndices = new Set();
            for (let i = 0; i < 16; i++) {
                knownIndices.add(i);
            }
            
            // 舊版本測試
            html += '<h3>舊版本（有bug）：</h3>';
            for (let test = 0; test < 5; test++) {
                const handCards = [];
                const availableIndices = [];
                
                for (let i = 0; i < 32; i++) {
                    if (!knownIndices.has(i)) {
                        availableIndices.push(i);
                    }
                }
                
                const shuffled = availableIndices.sort(() => Math.random() - 0.5);
                const selectedIndices = shuffled.slice(0, 4);
                
                // 舊邏輯
                selectedIndices.forEach(index => {
                    const cardType = allCardTypes[Math.floor(index / 2)];
                    handCards.push(cardType);
                });
                
                const { cardCount, hasDuplicateError } = checkDuplicates(handCards);
                html += `<p>測試 ${test+1}: ${hasDuplicateError ? '❌ 有重複錯誤' : '✅ 正常'} - [${handCards.join(', ')}]</p>`;
            }
            
            // 新版本測試
            html += '<h3>新版本（已修復）：</h3>';
            for (let test = 0; test < 5; test++) {
                const handCards = [];
                const availableIndices = [];
                
                for (let i = 0; i < 32; i++) {
                    if (!knownIndices.has(i)) {
                        availableIndices.push(i);
                    }
                }
                
                const shuffled = availableIndices.sort(() => Math.random() - 0.5);
                const selectedIndices = shuffled.slice(0, 4);
                
                // 新邏輯
                const cardTypeCount = new Map();
                selectedIndices.forEach(index => {
                    const cardType = allCardTypes[Math.floor(index / 2)];
                    const count = cardTypeCount.get(cardType) || 0;
                    cardTypeCount.set(cardType, count + 1);
                });
                
                cardTypeCount.forEach((count, cardType) => {
                    for (let i = 0; i < count; i++) {
                        handCards.push(cardType);
                    }
                });
                
                const { cardCount, hasDuplicateError } = checkDuplicates(handCards);
                html += `<p>測試 ${test+1}: ${hasDuplicateError ? '❌ 有重複錯誤' : '✅ 正常'} - [${handCards.join(', ')}]</p>`;
            }
            
            resultDiv.innerHTML = html;
        }
    </script>
</body>
</html>